* BASED ON SBC-85 BUBBLE MEMORY ROUTINES BY CRAIG ANDREWS, 2020
* COPYRIGHT 2019 (C) OF CRAIG ANDREWS ALL RIGHTS RESERVED

* READ/WRITE ROUTINES

* ********************************************************************
* **************  BUBBLE GET DATA AND SAVE INTO RAM  *******************
*   NAME: BBLGET
*   FUNCTION: READS BUBBLE DATA AND PUTS INTO RAM
*   INPUTS: DE=STARTING ADDRESS OF RAM, HL=NUMBER OF BYTES TO WRITE
*   OUTPUTS: NONE
*   USER IO: NONE
*   DESTROYS: A,H,L, F/F'S
*   CALLS: NOTHING
*   DESCRIPTION:
* 	TO USE SUBROUTINE:
* 	LOAD LSB OF BLOCK LENGTH IN BBLRL
* 	LOAD LSB OF BUBBLE ADDRESS INTO BARL
* 	LOAD MSB OF BUBBLE ADDRESS INTO BARH
* 	LOAD NUMBER OF BYTES TO TRANSFER INTO HL REGISTER PAIR
* 	LOAD STARTING ADDRESS OF RAM TO SAVE DATA INTO DE REGISTER PAIR
* 	CALL BBLREAD
* * ********************************************************************
BBLGET EQU *
*  CALL	NEWLINE			* UNCOMMENT FOR VERBOSE
*  MVI	A,'R'			* UNCOMMENT FOR VERBOSE
*  CALL	CO			* UNCOMMENT FOR VERBOSE

	PUSH	D		* SAVE NUMBER OF BYTES
	PUSH	B		* USED IN THIS ROUTINE
	LXI	B,0FFFFH	* LOAD TIMEOUT COUNTER
	MVI	A,12H		* LOAD READ BUBBLE MEMORY DATA COMMAND
	OUT	BBLCS		* SEND COMMAND TO 7220 COMMAND REGISTER
BBLGETB EQU *
	DCX	B		* DECREMENT TIMEOUT COUNTER
	XRA	A		* CLEAR ACCUMULATOR
	ORA	B		* SEE IF ANY B BITS SET
	ORA	C		* SEE IF ANY C BITS SET
	MVI	A,0EAH		* PRELOAD ERROR CODE
	JZ	BBLGETD		* IF ZERO, DONE BECAUSE OF TIMEOUT ERROR
	IN	BBLCS		* OTHERWISE, GET STATUS REGISTER
	RLC			* PUT BUSY BIT INTO CARRY
	JNC	BBLGETB		* LOOP UNTIL BUBBLE SETS BUSY INDICATING RECEIPT


BBLGETP EQU *
	IN	BBLCS		* GET BUBBLE STATUS
	RRC			* PUT FIFO AVAILABLE BIT INTO CARRY
	JC	BBLGETR		* SOMETHING IN FIFO, SO READ BYTE

	IN	BBLCS		* GET BUBBLE STATUS
	RLC			* TEST BUSY BIT
	MVI	A,0EBH		* PRELOAD ERROR B JUST IN CASE
	JNC	BBLGETD		* NOT BUSY, SO DONE BUT WITH ERROR

	DCX	B		* DECREMENT TIMEOUT COUNTER
	XRA	A		* CLEAR ACCUMULATOR
	ORA	B		* SET ANY BITS IN B THAT ARE SET
	ORA	C		* DO THE SAME FOR ANY BITS IN C
	MVI	A,0ECH		* PRELOAD ERROR C JUST IN CASE
	JZ	BBLGETD		* DONE DUE TO TIMEOUT ERROR
	JMP	BBLGETP		* HAVE NOT TIMED OUT, SO LOOP AGAIN

BBLGETR EQU *
	LXI	B,0FFFFH	* RESET TIMEOUT COUNTER
	IN	BBLDAT		* READ BYTE FROM BUBBLE
	STAX	D		* MOVE DATA BYTE INTO DE REGISTER ADDRESS
	INX	D		* INCREMENT TO NEXT MEMORY ADDRESS

	DCX	H		* DECREMENT DATA BYTE COUNTER
	XRA	A		* CLEAR ACCUMULATOR
	ORA	H		* ADD ANY BITS THAT ARE SET IN H
	ORA	L		* AND THEN ANY BITS SET IN L
	JNZ	BBLGETP		* LOOP UNTIL ALL BYTES ARE DONE OR ERROR OCCURS

*                                 NOW FLUSH OUT THE REMAINDER OF THE PAGE FROM FIFO
	LDA	BBLPUC		* GET THE PAGE UNUSED COUNT
	MOV	L,A		* PUT INTO L
	ORA	A		* SEE IF THERE IS A REMAINDER
 	JZ	BBLGETD		* NOPE, ALL DONE


BBLGFP EQU *
	IN	BBLCS		* GET BUBBLE STATUS
	RRC			* PUT FIFO AVAILABLE BIT INTO CARRY
	JC	BBLGFRD		* SOMETHING IN FIFO, GET IT
	IN	BBLCS		* GET BUBBLE STATUS
	RLC			* TEST BUSY BIT
	MVI	A,0EDH		* PRELOAD ERROR D
	JNC	BBLGETD		* NOT BUSY SO....DONE I GUESS?
	DCX	B		* DECREMENT TIMEOUT COUNTER
	XRA	A		* CLEAR ACCUMULATOR
	ORA	B		* SET ANY BITS IN B THAT ARE SET
	ORA	C		* DO THE SAME FOR ANY BITS IN C
	MVI	A,0EEH		* PRELOAD ERROR CODE
	JZ	BBLGETD		* DONE DUE TO TIMEOUT ERROR
	JMP	BBLGFP		* HAVE NOT TIMED OUT, SO LOOP AGAIN

BBLGFRD EQU *
	IN	BBLDAT		* GET BYTE FROM BUBBLE -> BITBUCKET
	DCR	L		* DECREMENT REMAINDER COUNTER
	JNZ	BBLGFP		* AND READ FROM FIFO UNTIL LAST DONE


BBLGETD EQU *
*  CALL HO			* UNCOMMENT FOR VERBOSE
*  CALL NEWLINE			* UNCOMMENT FOR VERBOSE
	POP	B		* RESTORE BC
	POP	D		* RESTORE DE
	RET			* RETURN TO CALL

* ********************************************************************
* **************  BUBBLE PUT DATA FROM RAM INTO BUBBLE  *******************
*   NAME: BBLPUT
*   FUNCTION: WRITES MEMORY DATA TO THE BUBBLE
*   INPUTS: DE=STARTING ADDRESS OF DATA, HL=NUMBER OF BYTES TO WRITE
*   OUTPUTS: NONE
*   USER IO: NONE
*   DESTROYS: A,H,L, F/F'S
*   CALLS: NOTHING
*   DESCRIPTION:
* 	TO USE SUBROUTINE:
* 	LOAD LSB OF BLOCK LENGTH IN BBLRL
* 	LOAD LSB OF BUBBLE ADDRESS INTO BARL
* 	LOAD MSB OF BUBBLE ADDRESS INTO BARH
* 	LOAD NUMBER OF BYTES TO TRANSFER INTO HL REGISTER PAIR
* 	LOAD STARTING MEMORY ADDRESS OF DATA TO BE SAVED INTO DE REGISTER PAIR
* 	CALL BBLWRIT
* * ********************************************************************
BBLPUT EQU *
*  CALL NEWLINE			* UNCOMMENT FOR VERBOSE
*  MVI A,'W'			* UNCOMMENT FOR VERBOSE
*  CALL CO			* UNCOMMENT FOR VERBOSE
	PUSH	D		* SAVE NUMBER OF BYTES
	PUSH	B		* USED IN THIS ROUTINE FOR TIMEOUT COUNTER
	LXI	B,0FFFFH	* LOAD TIMEOUT COUNTER
	MVI	A,13H		* LOAD WRITE BUBBLE MEMORY DATA COMMAND
	OUT	BBLCS		* SEND COMMAND TO 7220 COMMAND REGISTER
BBLPUTB EQU *
	DCX	B		* DECREMENT TIMEOUT COUNTER
	XRA	A		* CLEAR ACCUMULATOR
	ORA	B		* SEE IF ANY B BITS SET
	ORA	C		* SEE IF ANY C BITS SET
	MVI	A,0EAH		* PRELOAD ERROR CODE
	JZ	BBLPUTD		* IF ZERO, DONE BECAUSE OF TIMEOUT ERROR
	IN	BBLCS		* OTHERWISE, GET STATUS REGISTER
	RLC			* PUT BUSY BIT INTO CARRY
	JNC	BBLPUTB		* WAIT UNTIL BUSY GOES INDICATING RECEIPT OF COMMAND

BBLPUTP EQU *
	IN	BBLCS		* GET BUBBLE STATUS
	RRC			* PUT FIFO READY BIT INTO CARRY
	JC	BBLPUTW		* ROOM IN FIFO, SO ADD A BYTE
	IN	BBLCS		* GET BUBBLE STATUS
	RLC			* TEST BUSY BIT
	MVI	A,0EBH		* PRELOAD ERROR CODE
	JNC	BBLPUTD		* NOT BUSY, SO DONE BUT WITH ERROR

	DCX	B		* DECREMENT TIMEOUT COUNTER
	XRA	A		* CLEAR ACCUMULATOR
	ORA	B		* SET ANY BITS IN B THAT ARE SET
	ORA	C		* DO THE SAME FOR ANY BITS IN C
	MVI	A,0ECH		* PRELOAD ERROR CODE
	JZ	BBLPUTD		* DONE DUE TO TIMEOUT ERROR
	JMP	BBLPUTP		* HAVE NOT TIMED OUT, SO LOOP AGAIN

BBLPUTW EQU *
	LXI	B,0FFFFH	* RESET TIMEOUT COUNTER
	LDAX	D		* LOAD DATA FROM DE REGISTER ADDRESS
	OUT	BBLDAT		* SEND TO BUBBLE FIFO
	INX	D		* INCREMENT TO NEXT MEMORY ADDRESS

	DCX	H		* DECREMENT DATA BYTE COUNTER
	XRA	A		* CLEAR ACCUMULATOR
	ORA	H		* ADD ANY BITS THAT ARE SET IN H
	ORA	L		* AND THEN ANY BITS SET IN L
	JNZ	BBLPUTP		* LOOP UNTIL ALL BYTES ARE DONE OR ERROR OCCURS

	LDA	BBLPUC		* GET THE PAGE UNUSED COUNT
	MOV	L,A		* PUT INTO L

*                                 NOW NEED TO FILL UP THE REMAINDER OF THE PAGE
	ORA	A		* SEE IF THERE IS A REMAINDER
 	JZ	BBLPUTD		* NOPE, ALL DONE

BBLPFP EQU *
	IN	BBLCS		* GET BUBBLE STATUS
	RRC			* PUT FIFO AVAILABLE BIT INTO CARRY
	JC	BBLPFW		* ROOM IN FIFO, SO ADD A BYTE
	IN	BBLCS		* GET BUBBLE STATUS
	RLC			* TEST BUSY BIT
	MVI	A,0EDH		* PRELOAD ERROR CODE
	JNC	BBLPUTD		* NOT BUSY SO....DONE I GUESS?
	DCX	B		* DECREMENT TIMEOUT COUNTER
	XRA	A		* CLEAR ACCUMULATOR
	ORA	B		* SET ANY BITS IN B THAT ARE SET
	ORA	C		* DO THE SAME FOR ANY BITS IN C
	MVI	A,0EEH		* PRELOAD ERROR CODE
	JZ	BBLPUTD		* DONE DUE TO TIMEOUT ERROR
	JMP	BBLPFP		* HAVE NOT TIMED OUT, SO LOOP AGAIN

BBLPFW EQU *
 	MOV	A,L		* LOAD REMAINDER COUNTER, SAVE AS DATA BYTE (DIAGNOSTIC)
	OUT	BBLDAT		* SEND TO BUBBLE FIFO
	DCR	L		* DECREMENT REMAINDER COUNTER
	JNZ	BBLPFP		* AND OUTPUT NEXT FILLER UNTIL DONE

BBLPUTD EQU *
	IN	BBLCS		* GET BUBBLE STATUS
*  CALL HO			* UNCOMMENT FOR VERBOSE
*  CALL NEWLINE			* UNCOMMENT FOR VERBOSE
	POP	B		* RESTORE BC
	POP	D		* RESTORE DE
	RET			* RETURN TO CALL

* ********************************************************************
* **************  BUBBLE READ DATA FROM BUBBLE INTO RAM  *******************
*   NAME: BBLREAD
*   FUNCTION: READS BUBBLE DATA AND PUTS INTO RAM
*   INPUTS: DE=STARTING ADDRESS OF DATA, HL=NUMBER OF BYTES TO WRITE
*   OUTPUTS: RETURNS WITH BUBBLE STATUS IN ACCUMULATOR. 40H OR 42H = SUCCESS
*   USER IO: NONE
*   DESTROYS: A,F/F'S
*   CALLS: BBLFFR,BBL_LPR,BBL_BYTES,BBLPUT
*   DESCRIPTION:
* 	TO USE SUBROUTINE:
* 	BARL <- LSB OF BUBBLE ADDRESS
* 	BARH <- MSB OF BUBBLE ADDRESS
* 	HL <- NUMBER OF BYTES TO TRANSFER
* 	DE <- STARTING RAM ADDRESS OF DESTINATION
* 	CALL BBLREAD
* * ********************************************************************
BBLREAD EQU 	*
	DI			* DISABLE INTERRUPTS
	PUSH	D		* SAVE DE
	PUSH	H		* SAVE HL
	CALL	BBLABRT		* ABORT ANY COMMANDS BEING PROCESSED
	CALL	BBLFFR		* CALL BUBBLE FIFO RESET ROUTINE
	XRI	BSROCCM		* ONLY SUCCESSFUL ANSWER IS OPCODE COMPLETE
	JNZ	BBLRDDN		* IF DIDN'T FINSIH ABORT, WE ARE DONE WITH ERROR
	CALL	BBLCLBL		* CALCULATE AND LOAD BLOCK LENGTH TO BUFFER
	MVI	A,BBLEV		* GET ENABLE BYTE VALUE
	STA	BBLER		* BUBBLE ENABLE VALUE  -> BUFFER
	CALL	BBLPRL		* CALL LOAD PARAMETRIC REGISTER
	CALL	BBLGET		* READ BUBBLE DATA
	LXI	H,0FFFFH	* INITIALIZE TIMEOUT COUNTER
BBLRDLP EQU	*
	IN	BBLCS		* GET BUBBLE STATUS
	RLC			* PUT BUSY BIT INTO CARRY
	JNC	BBLRDDN		* IF NOT BUSY, RETURN
	DCX	H		* DECREMENT TIMEOUT COUNTER
	XRA	A		* CLEAR ACCUMULATOR
	ORA	H		* SET ANY BITS IN H THAT ARE SET
	ORA	L		* DO THE SAME FOR ANY BITS IN L
	JNZ	BBLRDLP		* HAVE NOT TIMED OUT, SO LOOP AGAIN

BBLRDDN EQU	*
	POP	H		* RESTORE HL
	POP	D		* RESTORE DE
	IN	BBLCS		* GET BUBBLE STATUS
	EI			* ENABLE INTERRUPTS
	RET			* RETURN TO CALL

* ********************************************************************
* **************  BUBBLE WRITE DATA FROM RAM INTO BUBBLE  *******************
*   NAME: BBLWRIT
*   FUNCTION: WRITES MEMORY DATA TO THE BUBBLE
*   INPUTS: DE=STARTING ADDRESS OF DATA, HL=NUMBER OF BYTES TO WRITE
*   OUTPUTS: RETURNS WITH BUBBLE STATUS IN ACCUMULATOR. 40H OR 42H = SUCCESS
*   USER IO: NONE
*   DESTROYS: A,F/F'S
*   CALLS: BBLFFR,BBL_LPR,BBL_BYTES,BBLPUT
*   DESCRIPTION:
* 	TO USE SUBROUTINE:
* 	BARL <- LSB OF BUBBLE ADDRESS
* 	BARH <- MSB OF BUBBLE ADDRESS
* 	HL <- NUMBER OF BYTES TO TRANSFER
* 	DE <- STARTING MEMORY ADDRESS OF SOURCE DATA
* 	CALL BBLWRIT
* * ********************************************************************
BBLWRIT EQU	*
	DI			* DISABLE INTERRUPTS
	PUSH	H		* SAVE HL
	CALL	BBLABRT		* ABORT ANY COMMANDS BEING PROCESSED
	CALL	BBLFFR		* CALL BUBBLE FIFO RESET ROUTINE
	XRI	BSROCCM		* ONLY SUCCESSFUL ANSWER IS OPCODE COMPLETE
	JNZ	BBLWRDN		* IF DIDN'T FINISH ABORT, WE ARE DONE BUT WITH ERROR
	CALL	BBLCLBL		* CALCULATE AND LOAD BLOCK LENGTH TO BUFFER
	MVI	A,BBLEV		* GET ENABLE BYTE VALUE
	STA	BBLER		* BUBBLE ENABLE VALUE  -> BUFFER
	CALL	BBLPRL		* CALL LOAD PARAMETRIC REGISTER
	CALL	BBLPUT		* WRITE BUBBLE DATA
	LXI	H,0FFFFH	* INITIALIZE TIMEOUT COUNTER
BBLWRLP EQU *
	IN	BBLCS		* GET BUBBLE STATUS
	RLC			* TEST FOR BUSY BIT
	JNC	BBLWRDN		* IF NOT BUSY, CLEAN UP AND RETURN
	DCX	H		* IF STILL BUSY, DECREMENT TIMEOUT COUNTER
	XRA	A		* CLEAR ACCUMULATOR
	ORA	H		* SET ANY BITS IN H THAT ARE SET
	ORA	L		* DO THE SAME FOR ANY BITS IN L
	JNZ	BBLWRLP		* HAVE NOT TIMED OUT, SO LOOP AGAIN

BBLWRDN EQU	*
	POP	H		* RESTORE HL
	IN	BBLCS		* GET BUBBLE STATUS
	EI			* ENABLE INTERRUPTS
	RET			* RETURN TO CALL

