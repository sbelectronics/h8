	TITLE	'BUBBLE - BUBBLE MEMORY TOOL'
	EJECT

* BASED ON SBC-85 BUBBLE MEMORY ROUTINES BY CRAIG ANDREWS, 2020
* COPYRIGHT 2019 (C) OF CRAIG ANDREWS ALL RIGHTS RESERVED

	XTEXT	HOSDEF
	XTEXT	HOSEQU
* stuff below is for cmdline parsing
	XTEXT	ASCII
	XTEXT	DIRDEF
	XTEXT	ESVAL
	XTEXT	ECDEF
	XTEXT	IOCDEF

	XTEXT	BBLDEF

DATABUF	EQU	03000H		* DATA BUFFER
DATARB	EQU	03100H		* DATA READBACK
DBEND	EQU	040H		* THE END OF DATABUF, HIGH BYTE
WORKBUF	EQU	04000H		* USER READ/WRITE WORK AREA
WBEND	EQU	050H		* THE END OF WORKBUF, HIGH BYTE

	ORG	05000H		* LEAVE ROOM FOR BUFFERS / WORK AREAS

ENTRY	JMP	START

*			  	  STUFF UP FRONT THAT IS USEFUL TO BE ABLE TO INSPECT
INPBUF 	DS	68D		* INPUT BUFFER

	XTEXT	BBLVAR

*			          SOME TEXT STRINGS TO USE AS INPUT FOR INTERACTIVE READ/WRITE
	DS	178		* PUT IT AT 0x5100
	ERRNZ	*-121000A
	DB	'Space, the final frontier.'
	DB	'These are the voyages of the Starship Enterprise.'
	DB	'Its five year mission'
	DB	'To explore strange new worlds'
	DB	'To seek out new life'
	DB	'And new civilizations'
	DB	'To boldly go where no man has gone before',200Q

START	LXI	H,BANMSG
	SCALL	.PRINT

	XRA	A		* CHARACTER MODE W/O ECHO
	MVI	B,201Q
	MVI	C,201Q
	SCALL	.CONSL

	CALL	BBLABRT		* ABORT ANY COMMANDS BEING PROCESSED
	CALL	HO
	CALL	BBLABRT		* ABORT ANY COMMANDS BEING PROCESSED
	CALL	HO

	CALL	BBLINIT		* INITIALIZE THE BUBBLE
	CALL	HO		* OUTPUT RETURN VALUE

BUBZERO EQU	*
	SUI	'0'
	MOV	B,A		* SAVE STARTING INCREMENTING VALUE
	LXI	H,WORKBUF
FILLLP	EQU	*
	MOV	M,B
	INX	H
	INR	B
	MOV	A,H
	CPI	WBEND
	JNZ	FILLLP

	LXI	H,DATABUF	* FILL DATABUF WITH 00H
FILLLP1 EQU	*
	MVI	M,00H
	INX	H
	MOV	A,H
	CPI	DBEND
	JNZ	FILLLP1
	JMP	CMDLOOP		* DONE

* main command loop
CMDLOOP EQU	*
	CALL	PROMPT		* SEND PROMPT TO TERMINAL
	CALL	CI
	CALL	CO

	CPI	'C'		* IS COMMAND TO CONFIGURE?
	JZ	BUBCONF		*  YES, CONFIGURE

	CPI	'N'		* IS COMMAND TO CONFIGURE?
	JZ	BUBCNF2		*  YES, CONFIGURE

	CPI	'D'		* IS COMMAND DUMP MEMORY?
	JZ	CMDD		*  YES, DUMP

	CPI	'I'		* IS COMMAND GET STATUS?
	JZ	BUBNIT		*  YES, GET AND DISPLAY

	CPI	'S'		* IS COMMAND GET STATUS?
	JZ	BUBSTAT		*  YES, GET AND DISPLAY

	CPI	'F'		* IS COMMAND TO FILL?
	JZ	BUBFIL		*  YES, FILL

	CPI	'G'		* IS COMMAND TO GET FIFO?
	JZ	BUBGET		*  YES, GET 40 BYTES

	CPI	'R'		* IS COMMAND TO READ?
	JZ	BUBRD		*  YES, READ

	CPI	'T'		* IS COMMAND TO TEST?
	JZ	BUBTEST		*  YES, TEST

	CPI	'W'		* IS COMMAND TO WRITE?
	JZ	BUBWRT		*  YES, WRITE

	CPI	'Z'		* IS COMMAND TO ZERO BUFFERS?
	JZ	BUBZERO		*  YES, CLEAN BUFFERS

	CPI	'#'		* IS THIS A NUMBERED COMMAND
	JZ	BUBNUMC		*  YES, SEND NUMBERED COMMAND

	CPI	'Q'
	JZ	QUIT

	MVI	A,BELL		* UNRECOGNIZED
	CALL	CO
	MVI	A,'?'
	CALL	CO
	JMP	CMDLOOP

QUIT	EQU	*
	XRA	A		* RESTORE LINE MODE WITH ECHO
	MVI	B,0Q
	MVI	C,201Q
	SCALL	.CONSL
	XRA	A
	SCALL	.EXIT

* Configure the 7220 parametric registers
BUBCONF	EQU	*
*  REGISTER B = 01H -> 1 PAGE TRANSFER
*  REGISTER C = 10H -> 1 2 CHANNELS (WHOLE BUBBLE)
*  REGISTER D = 08H -> 1 STANDARD TRANSFER RATE
*  REGISTER E = 00H -> 1 PAGE 0
*  REGISTER F = 00H -> 1 FIRST BUBBLE

	MVI	A,0BH		* SELECT BLOCK LENGTH LSB REGISTER
	OUT	BBLCS
	MVI	A,01H
	OUT	BBLDAT		* SEND BLOCK LENGTH LSB
	MVI	A,10H
	OUT	BBLDAT		* SEND BLOCK LENGTH MSB
	MVI	A,08H
	OUT	BBLDAT		* SEND ENABLE
	MVI	A,00H
	OUT	BBLDAT		* SEND ADDRESS PAGE (LSB)
	MVI	A,00H
	OUT	BBLDAT		* SEND ADDRESS BUBBLE (MSB)
	JMP	CMDLOOP		* DONE

BUBCNF2	EQU	*
*  REGISTER B = 01H -> 1 PAGE TRANSFER
*  REGISTER C = 10H -> 1 2 CHANNELS (WHOLE BUBBLE)
*  REGISTER D = 08H -> 1 STANDARD TRANSFER RATE
*  REGISTER E = 00H -> 1 PAGE 0
*  REGISTER F = 00H -> 1 SECOND BUBBLE

	MVI	A,0BH		* SELECT BLOCK LENGTH LSB REGISTER
	OUT	BBLCS
	MVI	A,01H
	OUT	BBLDAT		* SEND BLOCK LENGTH LSB
	MVI	A,10H
	OUT	BBLDAT		* SEND BLOCK LENGTH MSB
	MVI	A,08H
	OUT	BBLDAT		* SEND ENABLE
	MVI	A,00H
	OUT	BBLDAT		* SEND ADDRESS PAGE (LSB)
	MVI	A,08H
	OUT	BBLDAT		* SEND ADDRESS BUBBLE (MSB)
	JMP	CMDLOOP		* DONE


BUBFIL EQU	*
	LXI	H,BUBFILM
	MVI	B,40D		* FILL 40 BYTES IN BUBBLE FIFO
BUBFIL1 EQU	*
	MOV	A,M		* FILL CHARACTER IS COUNTER
	OUT	BBLDAT		* SEND TO BUBBLE
	INX	H
	DCR	B
	JNZ	BUBFIL1		* DO UNTIL DONE
	MVI	A,00H
	OUT	BBLDAT		* 00H IN BYTE 41 REQUIRED FOR DIAGNOSTIC WRITE BOOTLOOP
	JMP	CMDLOOP		* THEN RETURN

BUBFILM	DB	'FIFO BUFFER Fill 9 8 7 6 5 4 3 2 1 0 END'


* Bubble 7220 Commands used with the '#' command
* 0 - Write Boot Register Masked
* 1 - Initialize
* 2 - Read Bubble Data
* 3 - Write Bubble Data
* 4 - Reed Seek
* 5 - Read Bootloop Register
* 6 - Write Bootloop Register
* 7 - Write Bootloop
* 8 - Read FSA Status
* 9 - Abort
* A - Write Seek
* B - Read Bootloop
* C - Read Corrected Data
* D - Reset FIFO
* E - MBM Purge
* F - Software Reset
BUBNUMC EQU	*
	CALL	CI		* GET COMMAND NUMBER
	CALL	TOHEX
	ANI	0FH		* CLEAR TOP HALF

	CPI	06H		* GET CONFIRMATION ON WRITE OF BOOTLOOP REGISTER
	JZ	DANGER
	CPI	07H		* GET CONFIRMATION ON WRITE OF BOOTLOOP
	JZ	DANGER
	JMP	NODANGR

DANGER	PUSH	PSW
	LXI	H,MDANGER
	SCALL	.PRINT
	CALL	CI
	CALL	CO
	CPI	'D'
	JNZ	NUMABT
	CALL	CI
	CALL	CO
	CPI	'A'
	JNZ	NUMABT
	CALL	CI
	CALL	CO
	CPI	'N'
	JNZ	NUMABT
	CALL	CI
	CALL	CO
	CPI	'G'
	JNZ	NUMABT
	CALL	CI
	CALL	CO
	CPI	'E'
	JNZ	NUMABT
	CALL	CI
	CALL	CO
	CPI	'R'
	JNZ	NUMABT
	JP	NUMGD
NUMABT	LXI	H,MABORT
	SCALL	.PRINT
	POP	PSW
	JMP	CMDLOOP

NUMGD	CALL	NEWLINE
	POP	PSW

NODANGR	ORI	10H		* SET BIT 4
	OUT	BBLCS		* SEND TO BUBBLE
	CALL	HO		* DISPLAY VALUE SENT TO USER
	JMP	CMDLOOP		* THEN GET NEXT COMMAND

MDANGER DB	'TYPE DANGER TO CONTINUE: ',200Q
MABORT	DB	'ABORTED',200Q




* read the FIFO into the input buffer (0x4037)
BUBGET	EQU	*
	MVI	B,68D		* NUMBER OF BYTES TO READ
	LXI	H,INPBUF	* INPUT BUFFER
	CALL	SENDHL		* PRINT ADDRESS OF BUFFER
	CALL	NEWLINE
BUBGET1 EQU	*
	IN	BBLDAT		* GET DATA BYTE
	MOV	M,A		* SAVE TO RAM
	INX	H		* POINT TO NEXT MEMORY
	DCR	B		* ONE DONE
	JNZ	BUBGET1		* LOOP IF MORE
	JMP	CMDLOOP		* RETURN IF DONE

* get the 7220 status
BUBSTAT EQU	*
	IN	BBLCS		* GET STATUS
	CALL	HO		* DISPLAY TO USER AS HEX
	CALL	SENDSPC
	CALL	BOB
	JMP	CMDLOOP

* bubble init with status print
BUBNIT:	CALL	BBLINIT
	CALL	HO
	JMP	CMDLOOP

* USER INTERACTIVE WRITE TO THE BUBBLE
* 	TO USE SUBROUTINE:
* 	BARL <- LSB OF BUBBLE ADDRESS
* 	BARH <- MSB OF BUBBLE ADDRESS
* 	HL <- NUMBER OF BYTES TO TRANSFER
* 	DE <- STARTING MEMORY ADDRESS OF SOURCE DATA
* 	CALL BBLWRIT

BUBWRT EQU	*
	LXI	H,BWRMSGP	* REQUEST BUBBLE PAGE FROM USER
	CALL	SENDSTR
	CALL	GETHEXW		* GET IT
	SHLD	BAR		* SAVE IN RAM BUFFER FOR BUBBLE ROUTINES

	LXI	H,BWRMSGS	* ASK FOR DATA SOURCE ADDRESS FROM USER
	CALL	SENDSTR
	CALL	GETHEXW		* GET IT
	XCHG			* PUT INTO DE
	LXI	H,BWRMSGH	* ASK FOR NUMBER OF BYTES TO WRITE
	CALL	SENDSTR
	CALL	GETHEXW		* GET IT
	CALL	NEWLINE
	MVI	A,'P'		* PAGE
	CALL	CO
	LDA	BARH
	CALL	HO
	LDA	BARL
	CALL	HO
	MVI	A,'S'		* SOURCE ADDRESS
	CALL	CO
	CALL	SENDDE
	MVI	A,'#'		* # OF BYTES
	CALL	CO
	CALL	SENDHL
	CALL	NEWLINE
	CALL	BBLWRIT		* WRITE TO BUBBLE
	MOV	B,A		* SAVE RETURN CODE
	MVI	A,'S'		* WRITE RETURN CODE STATUS
	CALL	CO
	MOV	A,B		* RESTORE RETURN CODE
	CALL	HO		* DISPLAY RESULT OF CALL
	CALL	NEWLINE
	JMP	CMDLOOP		* DONE



* USER INTERACTIVE READ FROM THE BUBBLE
* 	TO USE SUBROUTINE:
* 	BARL <- LSB OF BUBBLE ADDRESS
* 	BARH <- MSB OF BUBBLE ADDRESS
* 	HL <- NUMBER OF BYTES TO TRANSFER
* 	DE <- STARTING MEMORY ADDRESS OF DESTINATION RAM
* 	THEN CALL BBLREAD
BUBRD EQU *
	LXI	H,BWRMSGP	* REQUEST BUBBLE PAGE FROM USER
	CALL	SENDSTR
	CALL	GETHEXW		* GET IT
	SHLD	BAR		* SAVE IN RAM BUFFER FOR BUBBLE ROUTINES

	LXI	H,BWRMSGD	* ASK FOR DATA DESTINATION ADDRESS FROM USER
	CALL	SENDSTR
	CALL	GETHEXW		* GET IT
	XCHG			* PUT INTO DE
	LXI	H,BWRMSGH	* ASK FOR NUMBER OF BYTES TO WRITE
	CALL	SENDSTR
	CALL	GETHEXW		* GET IT
	CALL	NEWLINE
	MVI	A,'P'		* PAGE
	CALL	CO
	LDA	BARH
	CALL	HO
	LDA	BARL
	CALL	HO
	MVI	A,'D'		* DESTINATION ADDRESS
	CALL	CO
	CALL	SENDDE
	MVI	A,'#'		* # OF BYTES
	CALL	CO
	CALL	SENDHL
	CALL	NEWLINE
	CALL	BBLREAD		* READ FROM THE BUBBLE
	MOV	B,A		* SAVE RETURN CODE
	MVI	A,'S'		* READ RETURN CODE
	CALL	CO
	MOV	A,B		* RESTORE RETURN CODE
	CALL	HO		* DISPLAY RESULT OF CALL
	CALL	NEWLINE
	JMP	CMDLOOP		* DONE


BWRMSGH	DB	LF,'NUMBER OF BYTES 0x0000-0x43BC - 0x',200Q
BWRMSGS	DB	LF,'SOURCE ADDRESS 0x0000-0xFFFF - 0x',200Q
BWRMSGD	DB	LF,'DESTINATION ADDRESS 0x0000-0xFFFF - 0x',200Q
BWRMSGP	DB	LF,'BUBBLE STARTING PAGE ADDRESS 0x0000-0X07FF- 0x',200Q



* BUBBLE QUICK TEST
* WRITE THE PAGE NUMBER TO EACH TWO-BYTE WORD AND THEN READ BACK
* CHECK IF READ-WRITE MATCH AND MOVE ON IF OK OR SEND MESSAGE IF NOT
BUBTEST EQU	*		* WRITE AND READ EACH BIT IN BUBBLE
	XRA	A		* CLEAR ACCUMULATOR
	STA	BARL		* SAVE BUBBLE STARTING PAGE NUMBER
	STA	BARH
	CALL	NEWLINE
	LXI	H,BUBTMSG	* MESSAGE TO USER
	CALL	SENDSTR

BUBTFIL EQU *			* FILL BUFFER WITH TWO-BYTE PAGE NUMBER
	LHLD	BAR
	CALL	SENDHL

	XCHG			* PAGE ADDRESS -> DE
	LXI	H,DATABUF	* DATA BUFFER

BUBTFLP EQU *
	MOV	M,D		* BIG ENDIAN FILL OF BUFFER WITH PAGE NUMBER
	INX	H
	MOV	M,E
	INX	H
	MOV	A,L		* FILL BYTE NUMBER
	CPI	BBLBPP		* LAST FILL LOCATION
	JNZ	BUBTFLP		* LOOP UNTIL DONE

	LXI	H,BBLBPP	* NUMBER OF BYTES TO WRITE
	LXI	D,DATABUF	* START OF FILL BUFFER DATA
	CALL	BBLWRIT		* WRITE TO BUBBLE

	LXI	H,BBLBPP	* NUMBER OF BYTES TO READ
	LXI	D,DATARB	* START OF OUTPUT BUFFER DATA
	CALL	BBLREAD		* READ FROM BUBBLE

BUBTSKP EQU	*


* NOW CHECK IF BUFFERS MATCH, SEND MSG WITH EACH ERROR
	LXI	H,DATABUF	* ORIGINAL DATA LOCATION
	LXI	D,DATARB	* READBACK DATA LOCATION

BUBTCHK EQU	*
	MOV	A,M		* GET ORIGINAL DATA
	XCHG			* HL=READBACK, DE=ORIGINAL
	CMP	M		* COMPARE ORIGINAL DATA WITH READBACK
	XCHG			* HL=ORIGINAL, DE=READBACK
	CNZ	BUBTFAI		* IF NOT A MATCH, DISPLAY ERROR
	INX	H
	INX	D
	MOV	A,L
	CPI	BBLBPP
	JNZ	BUBTCHK

	MVI	A,BS		* BACKSPACE OVER PAGE NUMBER
	CALL	CO
	CALL	CO
	CALL	CO
	CALL	CO
	LHLD	BAR		* GET BUBBLE PAGE
	INX	H		* INCREMENT
	SHLD	BAR		* SAVE PAGE NUMBER TO BUFFER

	MOV	A,H
	CPI	08H		* IS THE HIGH BYTE ONE PAST THE LAST BUBBLE PAGE?
	JNZ	BUBTFIL		*  NO, LOOP AGAIN
	MOV	A,L		* GET LOW BYTE
	CPI	00H		* IS THE LOW BYTE ONE PAST THE LAST BUBBLE PAGE?
	JNZ	BUBTFIL		*  NO, LOOP AGAIN
	JMP	CMDLOOP		*  YES, DONE SO RETURN

BUBTFAI EQU	*
	MOV	C,L		* BYTE NUMBER INTO C
	LXI	H,BTMFAB
	CALL	SENDSTR

	MOV	A,C		* GET BYTE NUMBER
	CALL	HO

	LXI	H,BTMFAW
	CALL	SENDSTR

	MVI	H,20H		* RESTORE HL TO ORIGINAL BUFFER
	MOV	L,C		*
	MOV	A,M		* GET ORIGINAL DATA
	CALL	HO
	LXI	H,BTMFAR
	CALL	SENDSTR
	MVI	H,21H		* HL = READBACK
	MOV	L,C		* RESTORE HL TO READBACK BUFFER
	MOV	A,M
	CALL	HO
	CALL	NEWLINE
	LXI	H,BUBTMSG	* OUTPUT PAGE MESSAGE AGAIN
	CALL	SENDSTR
	LHLD	BAR		* GET PAGE NUMBER AGAIN
	CALL	SENDHL		* DISPLAY FOR NEXT LOOP
	MVI	H,20H		* RESTORE BUFFER ADDRESSES
	MOV	L,C

	JMP	CMDLOOP		* XXX SMBAKER

	RET

BUBTMSG	DB	'TESTING PAGE --',200Q
BTMFAB	DB	'  FAILED ON BYTE --',200Q
BTMFAW	DB	'  WRITE VALUE --',200Q
BTMFAR	DB	'  READ VALUE --',200Q

* ********************************************************************
* *********************  DUMP MEMORY BRANCH  *************************
*   NAME: CMDD
*   FUNCTION: DISPLAYS BLOCK OF MEMORY
*   INPUTS: NONE
*   OUTPUTS: NONE
*   USER IO: REQUESTS STARTING AND ENDING ADDRESSES, DISPLAYS MEM VALUES BETWEEN
*   DESTROYS: A. F/F'S,BC,DE,HL
*   CALLS: HO, GETHEXW, SENDSTR, SENDHL, NEWLINE, SENDDE, CO
*   DESCRIPTION:THE USER IS ASKED FOR THE STARTING AND ENDING MEMORY ADDRESSES
*      THE PROGRAM THEN DISPLAYS THE VALUES OF MEMORY
* * ********************************************************************
CMDD	EQU	*
	LXI	H,CMDDSM	* MSG TO USER FOR START ADDRESS
	CALL	SENDSTR
	CALL	GETHEXW		* PUT STARTING ADDRESS INTO HL
	XCHG			* MOVE STARTING ADDRESS INTO DE
	LXI	H,CMDDEM	* ASK FOR ENDING ADDRESS
	CALL	SENDSTR
	CALL	GETHEXW		* PUT ENDING ADDRESS INTO HL
	XCHG			* SWAP SO START IN HL, END IN DE
	CALL	NEWLINE
 	CALL	SENDHL		* REPEAT BACK TO USER OUR UNDERSTANDING OF ADDRESSES
 	MVI	A,' '
 	CALL	CO
 	MVI	A,'T'
 	CALL	CO
 	MVI	A,'O'
 	CALL	CO
 	MVI	A,' '
 	CALL	CO
 	CALL	SENDDE
 	CALL	NEWLINE

CMDDLN EQU	*
	PUSH	H		* SAVE HL FOR LATER
	CALL	SENDHL		* SEND ADDRESS
	MVI	A,':'
	CALL	CO
	MVI	A,' '
	CALL	CO
	MVI	B,0FH+1		* NUMBER OF LOCATIONS PER LINE

CMDDCHR EQU	*
	MOV	A,M		* GET THE MEMORY VALUE
	CALL	HO		* DISPLAY M
	MOV	A,H		* SEE IF WE ARE DONE:
	CMP	D		* SEE HIGH BYTE IS THE SAME
	JNZ	CMDDNM		* IF NOT EQUAL, CONTINUE LOOP
	MOV	A,L
	CMP	E		* IF HIGH BYTE SAME, CHECK LOW BYTE
	JZ	CMDDHD		* DISPLAYED ENDING ADDRESS, WE ARE DONE


CMDDNM EQU *
	MVI	A,SPACE		* PUT A SPACE BETWEEN VALUES
	CALL	CO
	INX	H		* NEXT LOCATION
	DCR	B		* ONE LESS FOR THIS LINE
	JNZ	CMDDCHR		* MORE TO DO ON THIS LINE

CMDDHD EQU *
*                                 LINE IS DONE. LETS REDISPLAY AS ASCII
	POP	B		* WAS PUSHED AS H, GET BACK AS THE STARTING ADDRESS FOR LINE WE JUST DID
	PUSH	H		* SAVE OUR PLACE FOR NEXT LOCATION TO OUTPUT
	MOV	H,B		* M IS NOW BACK AT THE BEGINNING OF THE LINE
	MOV	L,C

	MVI	B,0FH+1		* NUMBER OF LOCATIONS PER LINE
	MVI	A,SPACE
	CALL	CO

CMDDAS EQU *
	MOV	A,M		* GET CHARACTER AGAIN
	CPI	SPACE		* LESS THAN SPACE
	JC	CMDDS4D		* NONDISPLAYABLE CHARACTER.  TO SMALL
	CPI	'~'
	JC	CMDDAS1		* DISPLAYABLE SO CONTINUE
CMDDS4D EQU *
	MVI	A,'.'

CMDDAS1 EQU *
	CALL	CO

CMDDNA EQU *
	MOV	A,H		* SEE IF WE ARE DONE:
	CMP	D		* SEE HIGH BYTE IS THE SAME
	JNZ	CMDDAC		* IF NOT EQUAL, CONTINUE LOOP
	MOV	A,L
	CMP	E		* IF HIGH BYTE SAME, CHECK LOW BYTE
	JZ	CMDDDN		* DISPLAYED ENDING ADDRESS, WE ARE DONE

CMDDAC EQU *
	DCR	B
	INX	H		* POINT TO NEXT
	JNZ	CMDDAS
*                                 WE ARE DONE WITH ASCII
	POP	H		* RESTORE LAST ADDRESS OUTPUT
	CALL	NEWLINE
	JMP	CMDDLN		* DO NEXT LINE

CMDDDN EQU	*		* DONE DISPLAYING MEMORY
	POP	H		* CLEAN UP STACK THE STACK
	CALL	NEWLINE
	JMP	CMDLOOP		* DONE HERE, RETURN TO COMMAND PROCESSOR

CMDDU	DB	'D -- (D)UMP MEMORY BETWEEN START AND END ADDRESSES',212Q
CMDDSM	DB	'HEX STARTING ADDRESS? (XXXX)',212Q
CMDDEM	DB	LF,'HEX ENDING ADDRESS? (XXXX)',212Q

	XTEXT	BBLCOM
	XTEXT   BBLRW
	XTEXT	SBCUTIL

SPACE	EQU	' '
BS	EQU	08H

BANMSG	DB	LF,'H8 Bubble Board Tool v0.1',212Q

	END	ENTRY
