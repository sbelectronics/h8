* BASED ON SBC-85 BUBBLE MEMORY ROUTINES BY CRAIG ANDREWS, 2020
* COPYRIGHT 2019 (C) OF CRAIG ANDREWS ALL RIGHTS RESERVED

* COMMON ROUTINES
*
* READ/WRITE ROUTINES ARE IN BBLCOM.ACM

* ********************************************************************
* **************  BUBBLE ABORT  *******************
*   NAME: BBLABRT
*   FUNCTION:SEND THE ABORT COMMAND TO THE 7220
*   INPUTS: NONE
*   OUTPUTS: RETURNS WITH BUBBLE STATUS IN ACCUMULATOR
*   USER IO: NONE
*   DESTROYS: A. F/F'S
*   CALLS: NOTHING
*   DESCRIPTION:SEND THE ABORT COMMAND TO 7220
* * ********************************************************************
BBLABRT EQU 	*
	CALL BBLAB1
	CALL BBLAB1
	RET

BBLAB1	EQU	*
*	MVI	A,'A'		* UNCOMMENT FOR VERBOSE
*	CALL	CO		* UNCOMMENT FOR VERBOSE
	PUSH	D		* DE USED FOR TIMEOUT COUNTER, SAVE
	LXI	D,0FFFFH	* LOAD COUNTER START VALUE
	MVI	A,19H		* ABORT COMMAND FOR 7220
	OUT	BBLCS		* SEND TO COMMAND REGISTER
BBLABBS EQU *
	IN	BBLCS		* GET BUBBLE STATUS REGISTER
	RLC			* TEST BUSY BIT =1
	JC	BBLABP		*  NOT BUSY, LEAVE THIS LOOP FOR NEXT
	DCX	D		* DECREMENT TIMEOUT COUNTER
	XRA	A		* CLEAR ACCUMULATOR
	ORA	D		*  ADD ANY SET BITS IN D
	ORA	E		*  THEN SAME FOR E
	JNZ	BBLABBS		* TIMEOUT IS NOT ZERO, SO CONTINUE POLLING
	MVI	A,0E1H		* RETURN WITH ERROR 1
	JMP	BBLABDN		* DONE, BUT WITH TIMEOUT ERROR

BBLABP EQU *
	IN	BBLCS		* READ STATUS REGISTER
	CPI	BSROCCM		* ONLY SUCCESSFUL ANSWER IS OPCODE COMPLETE
	JZ	BBLABDN		* DONE WITH SUCCESS
	DCX	D		* DECREMENT TIMEOUT COUNTER
	XRA	A		* CLEAR A
	ORA	D		*  ADD ANY SET BETS IN D
	ORA	E		*  ADD ANY SET BITS IN E
	JNZ	BBLABP		* IF NOT TIMEOUT, CONTINUE POLLING FIFO RESET CMD
	MVI	A,0E2H		* RETURN WITH ERROR 2

BBLABDN EQU *
	POP	D
*	CALL	HO			* UNCOMMENT FOR VERBOSE
*	CALL	NEWLINE			* UNCOMMENT FOR VERBOSE

	RET			* RETURN

* ********************************************************************
* **************  BUBBLE FIFO RESET  *******************
*   NAME: BBLFFR
*   FUNCTION:SEND THE FIFO RESET COMMAND TO THE 7220
*   INPUTS: NONE
*   OUTPUTS: RETURNS WITH BUBBLE STATUS IN ACCUMULATOR
*   USER IO: NONE
*   DESTROYS: A. F/F'S
*   CALLS: NOTHING
*   DESCRIPTION:SEND THE FIFO RESET COMMAND TO THE 7220 AND WAIT FOR
* 	THE OP-COMPLETE FLAG OR (BUSY OR COMPLETE) TIMEOUT, WHATEVER COMES FIRST
* * ********************************************************************
BBLFFR EQU *
*  MVI	A,'F'			* UNCOMMENT FOR VERBOSE
*  CALL	CO
	PUSH	D		* DE USED FOR TIMEOUT COUNTER, SAVE
	LXI	D,0FFFFH	* LOAD COUNTER START VALUE
	MVI	A,1DH		* FIFO RESET COMMAND FOR 7220
	OUT	BBLCS		* SEND TO COMMAND REGISTER
BBLFFRB EQU	*
	IN	BBLCS		* GET BUBBLE STATUS REGISTER
	RLC			* TEST BUSY BIT =1
	JC	BBLFFRP		*  NOT BUSY, LEAVE THIS LOOP FOR NEXT
	DCX	D		* DECREMENT TIMEOUT COUNTER
	XRA	A		* CLEAR ACCUMULATOR
	ORA	D		*  ADD ANY SET BITS IN D
	ORA	E		*  THEN SAME FOR E
	JNZ	BBLFFRB		* TIMEOUT IS NOT ZERO, SO CONTINUE POLLING
	MVI	A,0E3H		* RETURN WITH ERROR 3
	JMP	BBLFFRD		* DONE, BUT WITH TIMEOUT ERROR

BBLFFRP EQU *
	IN	BBLCS		* READ STATUS REGISTER
	CPI	BSROCCM		* ONLY SUCCESSFUL ANSWER IS OPCODE COMPLETE
	JZ	BBLFFRD		* DONE WITH SUCCESS
	DCX	D		* DECREMENT TIMEOUT COUNTER
	XRA	A		* CLEAR A
	ORA	D		*  ADD ANY SET BETS IN D
	ORA	E		*  ADD ANY SET BITS IN E
	JNZ	BBLFFRP		* IF NOT TIMEOUT, CONTINUE POLLING FIFO RESET CMD
	MVI	A,0E4H		* RETURN WITH ERROR 4 IN ACCUMULATOR

BBLFFRD EQU *
	POP	D
*  CALL HO			* UNCOMMENT FOR VERBOSE
*  CALL NEWLINE
	RET			* RETURN


* ********************************************************************
* **************  BUBBLE INITIALIZE  *******************
*   NAME: BBLINIT
*   FUNCTION:INITIALIZES BUBBLE MEMORY SYSTEM
*   INPUTS: NONE
*   OUTPUTS: RETURNS WITH BUBBLE STATUS IN ACCUMULATOR
*   USER IO: NONE
*   DESTROYS: A. F/F'S
*   CALLS: BBLABRT, BBLPRL
*   DESCRIPTION:THIS COMMAND IS REQURIED AFTER POWERUP AND MUST PRECEED
* 	ALL OTHER COMMANDS. IT FIRST LOADS THE RAM PARAMETER BUFFERS WITH
* 	THE REQUIRED DEFAULT VALUES FOR INITIALIZATION, THEN ABORTS ANY
* 	EXISTING BUBBLE COMMAND THAT MAY BE PROCESSING, AND THEN INITIALIZES
* 	THE BUBBLE.  IT WILL RETURN IF ANYTHING RESULTS IN A TIMEOUT OR ANY
* 	STATUS OTHER THAN AN OPERATION COMPLETE STATUS.
* * ********************************************************************
BBLINIT EQU *
*  MVI	A,'I'			* UNCOMMENT FOR VERBOSE
*  CALL	CO
	PUSH	D		* DE USED FOR TIMEOUT COUNTER, SAVE

	MVI	A,BBLRLV	* GET DEFAULT VALUE FOR BLOCK LENGTH LSB
	STA	BBLRL		* BUBBLE BLOCK LENGTH LSB -> BUFFER
	MVI	A,BBLRHVI	* GET INIT VALUE FOR BLOCK LENGTH MSB
	STA	BBLRH
	MVI	A,BBLEV		* GET ENABLE BYTE
	STA	BBLER		* BUBBLE ENABLE -> BUFFER
	MVI	A,BARLV		* GET DEFAULT BUBBLE ADDRESS LSB
	STA	BARL		* BUBBLE ADDRESS LSB-> BUFFER
	MVI	A,BARHVI	* GET DEFAULT BUBBLE ADDRESS MSB
	STA	BARH		* BUBBLE ADDRESS MSB-> BUFFER
	CALL	BBLABRT		* ABORT ANY COMMANDS BEING PROCESSED
	CPI	BSROCCM		* ONLY SUCCESSFUL ANSWER IS OPCODE COMPLETE
	JNZ	BBLINID		* IF DIDN'T FINSIH ABORT, WE ARE DONE WITH ERROR
	CALL	BBLPRL		* PARAMETRIC REGISTER LOAD
	MVI	A,BBLRHV	* RESTORE NORMAL VALUE FOR BLOCK LENGTH MSB
	STA	BBLRH
	LXI	D,0FFFFH	* LOAD TIMEOUT LOOP COUNTER
	MVI	A,11H		* LOAD INITIALIZE BUBBLE COMMAND
	OUT	BBLCS		* SEND INITIALIZE COMMAND TO BUBBLE

BBLINIB EQU *
	IN	BBLCS		* GET BUBBLE STATUS REGISTER
	RLC			* TEST BUSY BIT =1
	JC	BBLINIP		*  NOT BUSY, LEAVE THIS LOOP FOR NEXT
	DCX	D		* DECREMENT TIMEOUT COUNTER
	XRA	A		* CLEAR ACCUMULATOR
	ORA	D		*  ADD ANY SET BITS IN D
	ORA	E		*  THEN SAME FOR E
	JNZ	BBLINIB		* TIMEOUT IS NOT ZERO, SO CONTINUE POLLING
	MVI	A,0E5H		* RETURN WITH ERROR 5
	JMP	BBLINID		* DONE, BUT WITH TIMEOUT ERROR

BBLINIP EQU *
	IN	BBLCS		* READ STATUS REGISTER
	CPI	BSROCCM		* ONLY SUCCESSFUL ANSWER IS OPCODE COMPLETE
	JZ	BBLINID		* DONE WITH SUCCESS
	ANI	030H		* CHECK FOR A TIMING ERROR
	CPI	030H		* UH OH...
	JZ	BBLINID		* BAIL OUT, AS THINGS AREN'T GOING TO GET BETTER
	DCX	D		* DECREMENT TIMEOUT COUNTER
	XRA	A		* CLEAR A
	ORA	D		*  ADD ANY SET BETS IN D
	ORA	E		*  ADD ANY SET BITS IN E
	JNZ	BBLINIP		* IF NOT TIMEOUT, CONTINUE POLLING FIFO RESET CMD
	MVI	A,0E6H

BBLINID EQU *
	POP	D
*  CALL	HO			* UNCOMMENT FOR VERBOSE
*  CALL	NEWLINE
	RET			* RETURN


* ********************************************************************
* **************  BUBBLE PARAMETRIC REGISTER LOAD  *******************
*   NAME: BBLPRL
*   FUNCTION: FILLS BUBBLE PARAMETRIC REGISTERS WITH VALUES IN RAM BUFFER
*   INPUTS: NONE
*   OUTPUTS: NONE
*   USER IO: NONE
*   DESTROYS: A. F/F'S
*   CALLS: NOTHING
*   DESCRIPTION:SENDS THE PARAMETRIC REGISTER VALUES HELD IN RESERVED RAM
* 	LOCATIONS TO BUBBLE 7220. ENDS WITH PARAMETRIC REGISTER ADDRESS POINTING
* 	TO 7220 FIFO
* 	THE ENABLE REGISTER AND BLOCK LENGTH MSB ARE HARD CODED
* * ********************************************************************
BBLPRL EQU *
	MVI	A,BBLRLA	* GET STARTING REGISTER NUMBER
	OUT	BBLCS		* SET 7220 REGISTER POINTER TO BLR LSB
	LDA	BBLRL		* GET BLOCK LENGTH LSB VALUE FROM RAM BUFFER
	OUT	BBLDAT		* LOAD IN BLOCK LENGTH LSB REGISTER
	LDA	BBLRH
	OUT	BBLDAT		* LOAD IN BLOCK LENGTH MSB REGISTER
	LDA	BBLER		* GET ENABLE REGISTER VALUE
	OUT	BBLDAT		* LOAD IN BUBBLE ENABLE REGISTER
	LDA	BARL		* GET ADDRESS LSB
	OUT	BBLDAT		* LOAD IN BUBBLE AR_L REGISTER
	LDA	BARH		* GET ADDRESS MSB
	OUT	BBLDAT		* LOAD INTO BUBBLE ADDRESS MSB REGISTER
	IN	BBLCS		* GET STATUS BEFORE RETURN
	RET			* DONE LOADING 7220 REGISTERS, RETURN

* ********************************************************************
* ***********  BUBBLE CALCULATE AND LOAD BLOCK LENGTH  ***************
*   NAME: BBLCLBL
*   FUNCTION: CALCULATES THE BLOCK LENGTH AND LOADS INTO BUFFER FOR REGISTER LOAD
*   INPUTS: HL=NUMBER OF BYTES TO READ OR WRITE
*   OUTPUTS: BLOCK LENGTH LOADED INTO LSB REGISTER
*   USER IO: NONE
*   DESTROYS: A,F/F'S
*   CALLS:
*   DESCRIPTION:
* 	TO USE SUBROUTINE:
* 	HL <- NUMBER OF BYTES TO TRANSFER
* 	RESULT: CALCULATED BLOCK LENGTH -> BBLRL
*   EXAMPLE: HL=40 --> 01R04
* * ********************************************************************
BBLCLBL  EQU	*
	PUSH	B		* B=# OF PAGES, C=NUMBER OF BYTES LEFT ON THIS PAGE
	PUSH	H		* SAVE THE ORIGINAL COUNT
*  CALL	SENDHL			* UNCOMMENT FOR VERBOSE
	MVI	C,BBLBPP	* BUBBLE BYTES PER PAGE VALUE
	MVI	B,01D		* STARTING VALUE = 1 PAGE


BBLCLLP EQU *
	DCR	C
	JP	BBLCL1		* IF BYTES LEFT ON THIS PAGE, CONTINUE
	MVI	C,BBLBPP-1	* RELOAD BYTES PER PAGE
	INR	B		* SPILL OVER INTO ANOTHER PAGE SO INCREASE PAGE COUNT

BBLCL1 EQU	*
	DCX	H		* DECREMENT NUMBER OF BYTES LEFT
	XRA	A		* CLEAR ACCUMULATOR
	ORA	H		* SEE IF BYTE COUNT IS ZERO BY ADDING BITS TO ACCUMULATOR
	ORA	L		* FIRST H THEN L
	JNZ	BBLCLLP		* NOT ZERO, DO ANOTHER BYTE

*  MVI A,'='			* UNCOMMENT FOR VERBOSE
*  CALL CO			* UNCOMMENT FOR VERBOSE
	MOV	A,B		* MOVE NUMBER OF PAGES (BLOCKS) NEEDED INTO A
	STA	BBLRL		* NUMBER OF BLOCKS USED ROUNDED UP -> BUFFER
*  CALL HO			* UNCOMMENT FOR VERBOSE
*  MVI A,'r'			* UNCOMMENT FOR VERBOSE
*  CALL CO			* UNCOMMENT FOR VERBOSE
	MOV	A,C
	STA	BBLPUC		* NUMBER OF EMPTY PLACES LEFT IN PAGE  -> BUFFER
*  CALL	HO			* UNCOMMENT FOR VERBOSE
*  CALL	NEWLINE			* UNCOMMENT FOR VERBOSE
	POP	H
	POP	B
 	RET
